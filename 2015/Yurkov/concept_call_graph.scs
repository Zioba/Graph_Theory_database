sc_node_not_relation -> concept_call_graph;;

concept_call_graph
=> nrel_main_idtf:
	[Граф вызова] (* <-lang_ru;; *);
	[call graph] (* <-lang_en;; *);

<-rrel_key_sc_element:
				...
				(*
				<-sc_definition;;  => nrel_main_idtf: [Опр.(граф вызова)] (* <- lang_ru;; *);;
				<=nrel_sc_text_translation:
							...
							(*
							->[Граф вызовов в теории построения компиляторов — ориентированный граф, 
							который изображает вызовы между функциями в компьютерной программе. В частности,
							каждый узел представляет собой некоторую процедуру, а каждая дуга (f,g) показывает,
							что процедура f вызывает процедуру g.] (* <-lang_ru;text;; *);;
							*);;
				*);

<= nrel_using_constants:
			{
				concept_graph							
			};

<- rrel_key_sc_element:
			...
			(*
		<- sc_statement;;	
		<=nrel_sc_text_translation:
		...
			(*
				-> rrel_example: 
				 [граф вызовов — результат анализа программы, который может быть использован для понимания программы человеком, 
				или в качестве основы для дальнейших анализов. Одно простое применение графа вызовов — это поиск процедур,
				которые никогда не вызываются.] (*<-lang_ru;;*);;		
			*);;
		*);

<- rrel_key_sc_element:
			...
			(*
		<- sc_statement;;	
		<=nrel_sc_text_translation:
		...
			(*
				-> rrel_example: 
				 [Граф вызовов может быть динамическим или статическим. Динамический граф вызовов представляет собой запись выполнения программы.
					Статический граф вызовов предназначен для представления всех возможных вариантов выполнения программы.] (*<-lang_ru;;*);;
			*);;
			*);;
concept_connected_graph => nrel_inclusion:call_graph;;
