sc_node_not_relation -> call_graph;;

call_graph
=> nrel_main_idtf:
	[Граф вызова] (* <-lang_ru;; *);
	[call graph] (* <-lang_en;; *);

<-rrel_key_sc_element:
				...
				(*
				<-sc_definition;;  => nrel_main_idtf: [Опр.(граф вызова)] (* <- lang_ru;; *);;
				<=nrel_sc_text_translation:
							...
							(*
							->[Граф вызовов в теории построения компиляторов — ориентированный граф, который изображает вызовы между функциями в компьютерной программе. В частности, каждый узел представляет собой некоторую процедуру, а каждая дуга (f,g) показывает, что процедура f вызывает процедуру g.] (* <-lang_ru;text;; *);;
				
				<= nrel_using_constants:
				{
`					concept_graph
					
				};;						

			*);;
				*);

<- rrel_key_sc_element:
			...
			(*
		<- sc_statement;;	
		<=nrel_sc_text_translation:
		...
			(*
				-> rrel_example: 
				 [ вызовов — результат анализа программы, который может быть использован для понимания программы человеком, или в качестве основы для дальнейших анализов. Одно простое применение графа вызовов — это поиск процедур, которые никогда не вызываются.] (*<-lang_ru;;*);;
				<= nrel_using_constants:
				{
					concept_graph				
					
				};;		

			*);;
		*);

<- rrel_key_sc_element:
			...
			(*
		<- sc_statement;;	
		<=nrel_sc_text_translation:
		...
			(*
				-> rrel_example: 
				 [Граф вызовов может быть динамическим или статическим. Динамический граф вызовов представляет собой запись выполнения программы. Статический граф вызовов предназначен для представления всех возможных вариантов выполнения программы.] (*<-lang_ru;;*);;
			<= nrel_using_constants:
				{
					concept_graph				
					
				};;
			*);;
		*);;


concept_connected_graph => nrel_inclusion:call_graph;;
